---
title:  "Languages, Machines And Grammars"
description: "Chomsky Classification of Grammar. Unrestricted grammar, context sensitive grammar, context free grammar, regular grammar. Turing machine, linear bound automata, push down automata, finite state automata."
nav_order: 3
child_of: Theory Of Computation
sub: true
---

# Types of Languages

## Regualar Languages (REG)

- A languages accepted by **finite automaton** is called a **regular language.**
- A languages generated by **regular grammar** is called a **regular language.**

***

## Deterministic Context Free Language (DCFL)

- A languages accepted by **deterministic push down automaton** is called a **deterministic context free language.**

***

## Context Free Language (CFL)

- A languages accepted by **push down automaton (non-deterministic)** is called a **context free language.**
- A language generated by **context free grammar** is called **context free language.**

***

## Context Sensitive Languagae (CSL)

- A language accepted by a **linear bound automata** is called **context sensitive language.**
- A language generated by a **context sensitive grammar** is called **context sensitive language.**

***

## Recursive Language (REC)

- A language accepted by the **halting Turing machine** is called **recursive language.**
- If a language can be enumerated in a **lexicographic order** (particular order) by some Turing machine, then that language is called **recursive.**

***

## Recursive Enumeratble Langauge (REL)

- A language accepted by the Turing machine is called **recursive enumerable language.**
- If a language can be enumerated Turing machine, then that language is called **recursive;y enumerable.**

# Types of Automaton

## Finite Automaton (FA)

- An automaton that accepts a *regualar language* is called a **finite automaton.**
- Types of finite automaton:
    - **Deterministic finite automaton (DFA)**
    - **Non-deterministic finite automaton (NFA)**
    - **Non-deterministic finite automaton with ε moves (ε-NFA)**
- **L(DFA) ≅ L(NFA) ≅ L(ε-NFA)**
    - It means that language generated by any type of FA can be generated by any other type of FA.
    - **All FAs are have same expressive power.**

***

## Push Down Automaton (PDA)

- An automaton that accepts a *context free language* is called a **push down automata.**
- Types of push down automaton:
    - **Deterministic push down automaton (DPDA)**
    - **Non-deterministic push down automaton (NPDA or PDA)**
- **L(DPDA) < L(NPDA)>** i.e. **DPDA ⊂ NPDA**
    - Languages accepted by DPDA are proper subset of NPDA.
    - **NPDA has more expressive power than DPDA.**

***

## Linear Bound Automaton (LBA)

 - An automaton that accepts a *context sensitive language* is called a **linear bound automaton.**

***

## Turing Machine (TM)

- An automaton that accepts a *recursive enumerable language* is called a **turing machine.**
- TM can accept recursive enumerable language (TM as acceptor).
- TM can enumerate a recursive enumerable language (TM as an enumerator).
- Types of Turing machine (based on configuration):
    - **Deterministic Turing machine (DTM)**
    - **Non-deterministic Turing machine (NDTM)**
- **DTM and NDTM has same expressive power.**
- Standard Turing machine is deterministic Turing machine.
- Types of Turing machine (based on acceptance/enumeration):
    - **Halting Turing machine (HTM), Accepts recursive language.**
    - **Standard Turing machine (TM), Accepts recursive enumerable language.**
- **HTM has less expressive power than standard Turing machine,** i.e. L(HTM) ⊂ L(TM).

# Types of Grammars

- A grammar G is defined as a quadruple, **G = ( V, T , P, S)**.
    - **V** is a non-empty finite set of **non-terminals** or variables.
    - **T** or **∑** is a non-empty finite set of **terminal symbols** such that **V ∩ T = ∅.**
    - **S** where **S ∈ V**, is a special non-terminal (or variable) called the start symbol.
    - **P** is **( V ∪ T)<sup>*</sup> V ( V ∪ T)<sup>*</sup>** is a finite set of production rules.
- Rules of P (productions rules) gets more and more restricted as we go from type 0 grammar to type 3 grammar.

## Regular Grammar

- Also known as **type-3** grammar.
- Language defined by regular grammar are accepted by **Finite State machine**.
- A grammar is regular language iff it's either is **left linear** grammar or **right linear** grammar.
    - Left linear grammar: **V --> VT<sup>*</sup> \| T<sup>*</sup>**
        - **Example,**
            - S --> Aa
            - A --> Aa | a
    - Right linear grammar: **V --> T<sup>*</sup>V \| T<sup>*</sup>**
        - **Example,**
            - S --> aA
            - A --> aaA | a

***

## Context Free Grammar

- Also known as **type-1** grammar.
- Language defined by context free grammar are accepted by **Push Down automata**.
- Restrictions on CFG rule **X --> Y** are:
    - **X** is **V** (variable)
    - **Y** is **( V ∪ T)<sup>*</sup>** (any combination of variable and terminals)
    - **\|X\| = 1**, i.e. on LHS there sould be single variable.
- **Examples,**
    - **{S --> aSb \| ε}** is CFG.
    - **{S --> B, A --> aAbA \| a, B --> AB \| ε}** is CFG.

***

## Context sensitive Grammar

- Also known as **type-1** grammar.
- Language defined by context sensitive grammar are accepted by **Linear Bound automata**.
- Restrictions on CSG **X --> Y** are:
    - **X** is **( V ∪ T)<sup>*</sup> V ( V ∪ T)<sup>*</sup>**
    - **Y** is **( V ∪ T)<sup>+</sup>**
    - **\|X\| <= \|Y\|** i.e count of symbol in X is less than or equal to Y
- As per the rule we can't have length of the RHS less then LHS, hence we can't produce the null string or epsilon.
    - In order to solve that problem, the **production S --> ε is allowed** where,
        - S is start symbol.
        - S fo not appere on the right side.
- **Examples,**
    - **{S --> aAb \| aA --> cd}** is CSG.
    - **{S --> aAb \| as, aAb --> cfed }** is CSG.

***

## Recursive Enumerable / Unrestricted Grammar

- Also known as **type-0** grammar.
- Language defined by unrestricted grammar are accepted by **Turing machine**.
- Restrictions on REG **X --> Y** are:
    - **X** is **( V ∪ T)<sup>*</sup> V ( V ∪ T)<sup>*</sup>**
    - **Y** is **( V ∪ T)<sup>*</sup>** 
    - **X must contain al least one variable.**
- **Eample,**
    - **{S -->aBb \| bS, aA --> b}** is REG.
