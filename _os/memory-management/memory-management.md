---
title: Memory Management
parent: true
nav_order: 4
---

- Memory consists of a large array of words or bytes, each with its own address.
- Instruction use memory and register as oprands. Hence data must be either in memory or regsiters. If the data is not in memory or register then it must be moved there.

# Memory Protection

- To make sure that each process has a separate memory space, we need the ability to determine the range of legal addresses that the process may access.
- We can provide this protection by using **two registers,** 
    - **Base regsiter**
        - Holds the smallest legal address the process can access.
    - **Limit regsiter**
        - Specifies the size of the range.
-  Any attemptby a program executing in user mode to access operating-system memory orother users’ memory results in a **trap** to the operating system, which treats theattempt as a fatal error.
- The base and limit registers can be loaded only by the OS.
- The operating system, executing in kernel mode, is given unrestrictedaccess to both operating system memory and users’ memory.

![Memory Protection]({{ site.baseurl }}/assets/images/coa/memory-protection.png)

# Address Binding

- Program (an executable file we create by compiling and linking) resides on a disk.
- To be executed,the program must be brought into memory, then it becomes process and waits in queue to be executed.
- Most systems allow a user process to reside in any part of the physical memory.
- Addresses in the source program are generally symbolic i.e. variable names.
- A compiler will typicallybindthese symbolic addresses to relocatableaddresses (such as“14 bytes from the beginning of this module”).
- The linkageeditor or loader will in turn bind the relocatable addresses to absolute addresses(such as 74014).
- Binding can be done at any step:

## Compile time

- If you know at compile time where the process will reside in memory, then absolute code can be generated. 
- For example, if you know that a user process will reside starting at location R,then the generated compiler code will start at that location and extend up from there. 
- If, at some later time, the starting location changes, then it will be necessary to recompile this code.

## Load time

- If it is not known at compile time where the process will residein memory, then the compiler must generate relocatable code.
- In thiscase, final binding is delayed until load time. 
- If the starting address changes, we need only reload the user code to incorporate this changed value.

## Execution time

-  If the process can be moved during its execution from one memory segment to another, then binding must be delayed until runtime. 
- Special hardware must be available for this scheme to work.
- Most general-purpose operating systems usethis method.

# Logical Versus Physical Address Space

- An address generated by the CPU is referred to as a **logical address.**
    - Logical address also called virtual address.
- An address seen by the memory unit that is, the one loaded into the memory address register is commonly referred to as a **physical address.**
- The set of all logical addresses generated by a program is a **logical address space.**
- the set of all physicaladdresses corresponding to these logical addresses is a **physical address space.**
- The run-time mapping from virtual to physical addresses is done by ahardware device called the **memory management unit**(MMU).

# Static And Dynamic Linking/Loading


# Swapping

