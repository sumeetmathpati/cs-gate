---
title: Paging
child_of: Memory Management
nav_order: 4
sub: true
---

- If we don't have many modules in a program (say we only have main function) when our whole idea of segmentation will fail.
- Physical address space of process can be	non-contigous.
- Paging is a **fixed size partitioning scheme.**
- Each process is divided into fixed size blocks, each of which may reside in different part of memory.
	- The size of the last part may be less than the fixed size size.
- Divides physical memory into fixed size parts called **frames.**
	- Size of these frames are power of 2. Usually between 513 bytes of 16MB.
- Divides logical memory into blocks of same size as frames calles **pages.**
- Backing storage, where program is permanantly residing, is also split into storage units (called **blocks**), which are the same size as the frames and pages.
	- Sectors in a disk is made equal to the frames and pages.
- There is **no external fragmentation** in paging.
- **Internal fragmentation** may occur in the last page of the process.
- Keep track of all free frames.
	- To run a program of N pages need to find N free frames and load program from backing store.
- Setup **page table** to translate logical address to physical address.
- Page table is kept in memory.
	- **Page table base register (PTBR):** pointes to the page table.
	- **Page table length register (PTLR):** indicates the size of page table.
	- PTBR and PTLR are stored in PCB.
 
 # Address translation scheme
 
 - Assume logical address space is 2^m
 - Assume page size is 2^n
 - Address generated by CPU is divided into :
	 - **Page number (p):** used as an index into a **page table** which contains base address of each page in physical memory.
	 - Size of p = m - n.
	 - **Page offset (d):** Combinaed with base address of a page to define the physical memory address that is sent to the memroy unit.
	 - Size od d is n. 
 ![Screenshot from 2021-01-04 02-29-33.png]({{ site.baseurl }}/assets/images/coa/paging.png)
- Hence to access a single memory location we are accessing memory twice
	- Once to access page table and second time to access the memory.

# Allocating pages to the process

![Screenshot from 2021-01-04 11-20-46.png](:/7449b00be2264b9786d828276d11be30)

# Page table

- The page table is **in the main memory.**
- There is saperate page table for saperate process.
- The page table entry definitely constain the frame number.
- Page table has number of entries equal to the number of pages in logical address space.

# Translation lookaside buffer
 - The problem with the current approach is that to access single memory location, we have to access the memroy twice. 
	 - The reason is that the page table is in main meory.  
- The translation lookaside buffer is added to improve the performance of pages.
- It containes frequently reffered page numbers and their corresponding frame numbers.
- TLB is implemented by using **associative registers or TLB.**
- The TLB access time is very very less compared to main memory access time.

![Translating-Logical-Address-into-Physical-Address-Diagram.png](:/47471eb53f254ca0919a36ebbe32033a)

***

# Performance of paging

- Time required to execute a program = **x(c + m) + (1 - x)(c + 2m)**
	- x: TLB hit ratio
	- c: TLB access time
	- m: Memory access time

***

# Memory protection

- Any voilation cause trap to the system. 

## Read write

- Memory protection is implemented by assiciating protection bits which each frame to indicate if **read/only** or **read/write** access is allowed.
- Can also add more bits to indicate execute only.
- Example for text/code pages readonly access is provided and for data pages read write access is provided. 

## Valid invalid

- **Valid-invalid** bit attached to each entry in page table.
- **Valid** indicated that the addocited page is in the process's logical address space.
- **Invalid** indicates that the page is not in the process's logical address space. 
![Screenshot from 2021-01-04 12-19-34.png](:/b7bec9c9409d4f778c6be0feb806af22)
***

# Shares pages

## Shared pages

- One copy of **read-only** (reentrant) code shared among processes.
- Similar to multiple threads sharing same process space.
- Also useful for interprocess communication if sharing of read -write pages is allowed.

## Private code and data

- Each process keeps a separate copy of the code and data.
- The pages for the private code and data can appear anywhere in the logical address space. 

# Problem with paging

- Memory structure for paging can get huge using the straight forward methods.
- Consider a 32 bit logical address space and page size of 1 KB (2^10 B).
	- Page table would have 4 million entries (2^32 / 2^10).
	- If each entry is of 4 Bytes then page table is of size 16 MB
- And we have to store this table contigously.
- And it will get even more for 64 bit address space.

#  Multi-level paging

- Page tables are for each process and may ae very large size and hence they are overhead on system. 
	- Thats why we use multi level paging.
- Page table used to represent pages of page table is called **page table of page table.**

## Performance of multilevel paging

- TLB is added to improve the performance of paging.
- TLB constains page number and frequently reffered page numbers and their correpsonding frame numbers.
	- TMP is implemented by associatinve registers.
- **Effective memory access time**
	- x(c+m) + (1-x)(c+3m)  ...(for 2 level paging)
	- x(c+m) + (1-x)(c+(n+1)m)  ...(for n level paging)
		- x: TML hit ratio
		- c: TLB access time
		- m: memory access time

***

![Multilevel-Paging-Illustration-Diagram-1.png](:/a62f8c1eb48b484ea3ff5284e8a0ae27)


#  Inverted paging

- In paging as the number of processes increase, number of page tables increase.
	- Because page tables are created for each proccess.
- To reduce this overhead we use inverted paging.
- In inverted paging we create a single page table for all the processes.
- Number of entries in the page table are equal to the number of frames in memory or physical space.
- CPU searches for frame with page number and and PID.
- Searching time for curresponding page for the process will be more.

